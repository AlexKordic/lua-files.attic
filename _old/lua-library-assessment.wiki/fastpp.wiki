#sidebar GlueSidebar

*`fastpp.fastdumps(v[,options]) -> s`*<br>
Fast, compact serialization producing portable Lua source code.
  * optional loop detection and/or depth limitation.
  * optionally skip and/or break on unserializable objects.
  * options: `{unserializable = 'skip'|'abort', detect_loops = true|false, max_depth = n}`

The output is _compact_ (no spaces, no quoting of identifier keys, minimal quoting of strings), _portable_ between Lua 5.1, Lua 5.2 and LuaJIT2 (ascii-only unbracketed keys, numbers in decimal), portable between Windows, Linux, Mac (quoting of \n and \r), _embeddable_ (can be copy-pasted into Lua source code: quoting of \0 and \t prevents modification by code editors).

The implementation is economic: linear time, low garbage and not stack bound.

*`fastpp.fastloads(s) -> v`*<br>
Wrapper of Lua `load` for loading back a serialized value.

{{{
import'fastpp'
t = fastpp.fastloads(fastpp.fastdumps{a=1,b={x=5,y=7},1,2,3})
}}}

Limitations of the method:
  * some fractions are not compact eg. 5/6 takes 19 bytes vs 8 bytes native.
  * strings suffer escaping which might become noticeable in large strings with plenty newlines, tabs, zero bytes, apostrophes or backslashes.
  * multiple table references are dereferenced without warning (i.e. identities are not tracked nor preserved).
  * the loader is not protected against malicious code doing infinite loops or infinite heap allocations (the loading environment is clean though).